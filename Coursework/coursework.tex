\documentclass[bachelor, och, coursework, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage{minted}
\setminted{       % установка параметров по умолчанию для команд бибилиотеки minted
%	bgcolor=codebg, % установка цвета фона программного кода
	linenos=true,   % включение номеров строк в листингах
	numbersep=5pt,  % промежуток между номерами строк и началом строк листинга
	breaklines}     % автоматические переносы строк (когда строки не умещаются)
\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Сравнение игровых движков Unity и Construct 2}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Яшина Егора Александровича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н., доцент} % степень, звание
\chname{А.\,С.\,Иванов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{А.\,С.\,Иванова}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
%\patitle{к.\,ф.-м.\,н., доцент}
%\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
%\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
%\practStart{01.07.2016}
%\practFinish{14.07.2016}

% Год выполнения отчета
\date{2020}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе


% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
В современном мире немалую часть рынка развлечений занимают игры, каждая из них создана на своем игровом движке. Игровых движков в мире также имеется достаточное количество, и при выборе нужного разработчик может подобрать под свои нужды и желания. Но как же определить нужный движок? Цель работы --- сравнить основные характеристики выбранных движков, разработать одинаковую игру на выбранных движках и определить предпочитаемую область разработки на каждом из движков.

\section{Обзор возможностей игровых движков}
\subsection{Construct 2}
\mintinline{C++}{Construct} 2 является движком, основанным на \mintinline{C++}{HTML5} и позволяющим создавать двухмерные игры. Отличительной особенностью движка \mintinline{C++}{Construct} является полное отсутствие кода, вместо него используются события. Событие --- это логическое ветвление, состоящее из условия, которое может быть создано с помощью конструкций <<И>>, <<Или>>, и действия, которое может включать в себя как набор последовательных команд так и одиночную команду.

Проект в \mintinline{C++}{Construct} разделяется на макеты и листы событий. Макет представляет собой рабочую область, в которой располагаются игровые объекты. Макет имеет собственные параметры такие как название, размер видимой рабочей области, лист событий, который работает в данном макете.\cite{gd_html5} Макет пустого проекта представлен на рисунке ~\ref{fig:Const-workplaces}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.39]{Construct_workplace.png}
    \caption{Макет пустого проекта}\label{fig:Const-workplaces}
\end{figure}

При создании нового объекта, выбирается тип объекта, которым он является, и в зависимости от типа будут определенны параметры и события доступные данному элементом. Все возможные типы объектов приведены на рисунке ~\ref{fig:Construct_objects}. Для включения определенных средств ввода нужно добавление объекта с типом требуемого средства ввода. \cite{gd_html5}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{Construct_objects.png}
    \caption{Все типы объектов}\label{fig:Construct_objects}
\end{figure}

Для большинства типов объектов можно добавить новые параметры и возможности с помощью поведения объекта. Все возможные поведения приведены на рисунке ~\ref{fig:Const-behav}. Поведение объекта является еще одним важным элементом \mintinline{C++}{Construct}, поведение задает шаблоны действий объекта в зависимости от параметров поведения. К примеру поведение платформ представляет собой готовый объект игрока для игрового жанра платформер, в данном жанре основными действиями является перемещение и прыжок, поведение платформ предоставляет возможность настроить скорость перемещения и прыжка, также устанавливается базовое управление на клавиши <<Влево>> и <<Вправо>> движение в соответствующие стороны и на клавишу <<Вверх>> устанавливается прыжок.\cite{gd_const}

\newpage

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_behaviors.png}
    \caption{Все поведения объекта}\label{fig:Const-behav}
\end{figure}

\mintinline{C++}{Construct} предоставляет инструменты для создания новых объектов, требующих графическое изображение внутри движка. Так при создании нового объекта типа спрайта открывается графический редактор который, позволяет нарисовать новое изображение в движке либо загрузить уже существующее, позволяет настроить границы соприкосновения объекта и исходную точку, также внутри редактора можно настроить анимации объекта и их количество. Пример редактора приведён на рисунке ~\ref{fig:Construct_paint}.
\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_paint.png}
    \caption{Графический редактор}\label{fig:Construct_paint}
\end{figure}

\newpage

Лист событий представляет собой последовательное расположение всех событий проекта. Пример листа событий приведен на рисунке ~\ref{fig:Const-eventsheet}. Для добавления нового события на листе событий выбираются объект и условие допустимые движком, после этого выбирается другой или уже выбранный объект и допустимое движком действие с этим объектом. Примером может являться перемещение персонажа влево при нажатии клавиши \mintinline{C++}{A}, для этого проект должен включать объект типа клавиатуры для считывания нажатой клавиши и объект типа платформер для создания перемещения. Как логическое условие берется нажатие клавиши \mintinline{C++}{A}, действием будет являться симуляция передвижения влево. Вид этого события приведён на рисунке ~\ref{fig:Const-eventexample}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.4]{Construct_eventsheet.png}
    \caption{Лист событий}\label{fig:Const-eventsheet}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_eventexample.png}
    \caption{Пример события}\label{fig:Const-eventexample}
\end{figure}

\newpage

\mintinline{C++}{Construct} является проприетарным движком. Он имеет бесплатную версию с ограничениями, то есть отсутствуют функции и возможность коммерческого использования, также имеется лимит по количеству событий. Существует две платные версии: одна для бизнеса другая для персонального использования. Все отличия бесплатной версии от платных представлены в таблице ~\ref{tab:Const-versions}.  Различия в функционале этих версий отсутствуют в них присутствуют все возможные функции без ограничений, но существует условие что персональную версию нельзя использовать после заработанных 5000\$ с помощью этого движка. Соответственно платные версии отличаются в цене 200\$ за персональную версию и 500\$ за бизнес.\cite{Constr_of} 

\begin{table}[!ht]
    \small
    \caption{Отличия в лицензиях \mintinline{C++}{Construct} 2}\label{tab:Const-versions}
    \begin{tabular}{|l|l|l|}\hline
    Характеристика & Бесплатная лицензия & Платные лицензии\cr\hline
    Вкладка просмотра отладчика & Отсутствует & Присутствует\cr\hline
    Профайлер & Отсутствует & Присутствует\cr\hline
    Точки остановки для event	 & Отсутствует & Присутствует\cr\hline
    
    Создание \mintinline{C++}{iOS} приложений	 & Отсутствует & Присутствует\cr\hline
    Создание \mintinline{C++}{Android} приложений	 & Отсутствует & Присутствует\cr\hline
    Создание \mintinline{C++}{Windows} приложений	 & Отсутствует & Присутствует\cr\hline
    Создание \mintinline{C++}{Mac} приложений & Отсутствует & Присутствует\cr\hline
    Создание \mintinline{C++}{Linux} приложений	 & Отсутствует & Присутствует\cr\hline
    Создание \mintinline{C++}{Amazon Store} приложений	 & Отсутствует & Присутствует\cr\hline
    Создание игр для \mintinline{C++}{Wii U} 	 & Отсутствует & Присутствует\cr\hline
    Внутриигровые покупки		 & Отсутствует & Присутствует\cr\hline
    
    Максимальное количество событий	 & 100 & Неограниченно \cr\hline
    Максимальное количество сцен	 & 4 & Неограниченно\cr\hline
    Максимальное количество особых эффектов & 2 & Неограниченно\cr\hline
    Подпапки проекта	 & Отсутствует & Присутствует\cr\hline
    Поиск событий	 & Отсутствует & Присутствует\cr\hline
    Панель расположения z"=порядка	 & Отсутствует & Присутствует\cr\hline    
    Семейства объектов	 & Отсутствует & Присутствует\cr\hline
    Мгновенный просмотр	 & Отсутствует & Присутствует\cr\hline
    \end{tabular}
\end{table}

\newpage

\subsection{Unity}
\mintinline{C++}{Unity} является игровым движком, который позволяет создавать как двухмерные так и трехмерные игры. Особенностью \mintinline{C++}{Unity} является то что все объекты являются сущностями. Сущность --- это представление любого объекта, который может быть представлен в игре. Сущностью могут являться медиа файлы принадлежащие проекту, файлы созданные \mintinline{C++}{Unity}, скрипты. 

Проект в \mintinline{C++}{Unity} представляет безграничную рабочую область, в которой расставляются все игровые объекты задействованные в данной сцене. Рабочая область использует собственные значения для определения размера объекта внутри себя называемые юнитами, в следствии этого при загрузке нового графического файла требуется указать сколько пикселей будет внутри 1 юнита. В рабочей области можно располагать объекты как в трехмерном так и в двухмерном пространстве.\cite{gd_unity}  \mintinline{C++}{Unity} позволяет производить переключение между пространствами в любой момент разработки проекта, это позволяет определить расположение объектов относительно друг друга в разработке двухмерных игр, и позволяет производить разработку игр со смешанным пространством.\cite{gd_unity_2d} Пример расположения двухмерных объектов в трехмерном пространстве приведен на рисунке ~\ref{fig:Unity-zlayers}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{Unity_zlayers.png}
    \caption{Расположение двухмерных объектов в трехмерном пространстве}\label{fig:Unity-zlayers}
\end{figure}

Любой игровой объект представленный в рабочей области обладает компонентом \mintinline{C++}{tranform}, то есть компонентом, который определяет положение объекта внутри сцены. Для отображения и взаимодействия объекта с другими объектами требуется добавить новые компоненты. К примеру для отображения используется компонент \mintinline{C++}{sprite renderer}, который производит рендер изображения с параметрами свойства \mintinline{C++}{transform}, физические свойства объекта определяются самим движком и инициализируются компонентами \mintinline{C++}{rigidbody2d} или \mintinline{C++}{rigitbody} в зависимости от требуемого пространства. Пример объекта с несколькими компонентами представлен на рисунке ~\ref{fig:Unity-components}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.6]{Unity_components.png}
    \caption{Объект с несколькими компонентами}\label{fig:Unity-components}
\end{figure}

\newpage

\mintinline{C++}{Animator} является свойством требуемым для отображения анимации, \mintinline{C++}{Unity} имеет инструменты для создания новых анимаций и создание условий перехода между разными видами анимаций. Для создания новой анимации достаточно создать пустую анимацию и добавить её к объекту, после этого для добавления новых кадров нужно перенести графические файлы в поле анимации, также анимация может иметь вызов функции по достижению определённого времени внутри себя. \cite{gd_unity} Пример анимации на рисунке ~\ref{fig:Unity-animation}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.6]{Unity_animation.png}
    \caption{Анимация в \mintinline{C++}{Unity}}\label{fig:Unity-animation}
\end{figure}

Переход анимаций в \mintinline{C++}{Unity} может происходить  при определённом условии, \mintinline{C++}{animator} может включать в себя переменные типов \mintinline{C++}{bool, int, float, trigger} и при достижении нужного состояния переменных для смены анимации произойдёт смена на новую анимацию с первого кадра. Каждый переход будет отображаться стрелочкой направляющей в анимацию, в которую будет осуществлен переход. Пример \mintinline{C++}{Animator} с переходами анимаций представлен на  рисунке ~\ref{fig:Unity-animatorchange}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.6]{Unity_animatorchange}
    \caption{Animator с переходами анимаций}\label{fig:Unity-animatorchange}
\end{figure}

Для изменения параметров свойств объектов программным путём используются скрипты. В \mintinline{C++}{Unity} скрипты могут быть написаны как на \mintinline{C++}{C}\# --- \mintinline{C++}{Unity Scripting Api}\cite{MSDN} так и на \mintinline{C++}{JavaScript} --- \mintinline{C++}{UnityScript}. Пустой скрипт включает в себя библиотеки требуемые для написания на языке \mintinline{C++}{Unity}, и две функции \mintinline{C++}{Start} и \mintinline{C++}{Update}. \mintinline{C++}{Start} перед первым кадров. Функция \mintinline{C++}{Update} вызывается в проекте каждый кадр.\cite{gd_unity_c} Пустой скрипт на \mintinline{C++}{C}\# выглядит так:

\begin{minted}[fontsize=\small]{c++}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
\end{minted}
Форма распространения \mintinline{C++}{Unity} является проприетарной. Видов подписок четыре: \mintinline{C++}{Personal, Plus, Pro, Enterprise}. Все подписки доступны для коммерческого использования но имеется ограничение по годовому заработку пользователя определенной лицензии.  Различия подписок еще заключаются в возможностях при разработке приложения.\cite{Unity_of} Все отличия подписок представлены в таблице ~\ref{tab:Unity-subsr}.

\begin{table}[!ht]
    \small
    \caption{Отличия в подписках \mintinline{C++}{Unity}}\label{tab:Unity-subsr}
    \begin{tabular}
     %\multicolumn{5}{|l|}{V-В СОСТАВе X-НЕ ВХОДИТ В СОСТАВ +-ДОСТУПНО ЗА ДОПОЛНИТЕЛЬНУЮ ПЛАТУ}
    {|p{7.3cm}|l|l|l|l|}\hline
    \multicolumn{5}{|l|}{V --- в состае, X --- не входит в состав, + --- доступно за дополнительную плату}\cr\hline
    Характеристика & \mintinline{C++}{Personal} & \mintinline{C++}{Plus} & \mintinline{C++}{Pro} & \mintinline{C++}{Enterprise}\cr\hline
    Ограничения по годовому заработку  & $\leqslant$ 100000\$ & $\leqslant$ 200000\$& > 200000\$ & > 200000\$ \cr\hline
    \mintinline{C++}{Pro Editor UI} & X & V & V & V\cr\hline
    Управление заставочным экраном & X & V & V & V\cr\hline
    Пакет графических ресурсов высокого разрешения & X & X & V & V\cr\hline
    Доступ к исходному коду  & X & X& + & + \cr\hline
    Специальные отраслевые решения & X & X & X & +\cr\hline
    \mintinline{C++}{Advanced Cloud Diagnostics} & X & V & V & V\cr\hline
    Основная аналитика & X & V & V & V\cr\hline
    \mintinline{C++}{Analytics}: 50 ГБ экспорта необработанных данных в месяц & X & X & V & V\cr\hline
    Доступ к \mintinline{C++}{Unity Learn Premium} & + & V & V & V\cr\hline
    Приоритетный доступ к консультантам по успеху \mintinline{C++}{Unity} & X & X & V & V\cr\hline
    Приоритетная очередь клиентской поддержки & X & X & V & V\cr\hline
    \mintinline{C++}{Premium Support} & X & X & + & +\cr\hline
    Встроенные услуги \mintinline{C++}{Success Service} & X & X & X & +\cr\hline
    Стоимость в месяц & Бесплатно & 40\$ & 150\$ & Гибкая цена\cr\hline
    \end{tabular}
\end{table}

Также существует вариант студенческой подписки для этого студент должен иметь возраст, юридически достаточный для согласия на сбор и обработку персональных данных, и быть зарегистрированным в \mintinline{C++}{GitHub Student Developer Pack}. Эта подписка является бесплатной и предоставляет возможности, которых в обычной нет. Этими возможностями являются неограниченный доступ к \mintinline{C++}{Learn Premium}, пять рабочих мест в \mintinline{C++}{Unity Teams Advanced}, темная тема пользовательского интерфейса и диагностика реального времени в облаке.\cite{Unity_of}
\section{Сравнение движков}


\subsection{Сложность}
При знакомстве с новым движком пользователь может запутаться в его строении и сделать решение сменить среду разработки.

Хоть в \mintinline{C++}{Unity} большинство скриптов пишется на \mintinline{C++}{C}\#, который проще чем \mintinline{C++}{C++}, и сам движок предоставляет возможность создать все, что разработчик может себе представить. Но именно множество возможностей и ошеломляет нового пользователя, который не знает с чего лучше начать изучение. \mintinline{C++}{Unity} предоставляет бесплатные обучающие уроки, однако в большом количестве информации очень легко запутаться, особенно если материал затрагивает темы не изученные пользователем. С другой стороны за всё время существования \mintinline{C++}{Unity} было создано глобальное сообщество разработчиков, с его помощью можно найти требуемый материал если не на родном языке то на английском точно. Из-за сложности в начале разработки происходит ограничения для людей, которые не знают основ требуемых для создания нового проекта.\cite{gd_unity}

\mintinline{C++}{Construct} является движком, который значительно проще \mintinline{C++}{Unity}, это добивается отсутствием кода. Использование поведения объектов и событий сокращает код используемый в скриптах на \mintinline{C++}{Unity} до одного события. Они как и поведения будут понятны почти каждому, построение нового события может быть переводом простого предложения в логическое высказывания. Эти возможности позволяют разработку на \mintinline{C++}{Construct} почти каждому человеку.

\subsection{Занимаемая память и скорость запуска}
При установке движков иногда может возникнуть вопрос доступной памяти для него. И\mintinline{C++}{Constuct} с \mintinline{C++}{Unity} имеют значительную разницу в весе на диске. \mintinline{C++}{Construct} не требует дополнительных установок кроме самой версии движка, которая занимает около 120МБ. \mintinline{C++}{Unity} же рекомендует установить программу для управлением версиями и проектами называемую --- \mintinline{C++}{Unity Hub}, которая занимает  почти 200МБ, в то время сама версия \mintinline{C++}{Unity} весит около 6.5 ГБ.

Следовательно из-за разности веса эти движки имеют совсем разное время запуска. В то время как \mintinline{C++}{Construct} в среднем за несколько секунд и можно сразу же заниматься разработкой, \mintinline{C++}{Unity} может запускать пустой проект в течении нескольких минут.

\subsection{Поддерживаемые платформы}
В \mintinline{C++}{Construct} экпорт проекта происходить с помощью перевода на \mintinline{C++}{JavaScript}. Тем самым разработчик может создать игру для платформ, которые имеют поддержку \mintinline{C++}{Web}.\cite{Gamesparks}

При установке \mintinline{C++}{Unity} разработчик должен выбрать требуемые ему модули сборки проекта. Для движка существуют модули для любой платформы созданной на данный момент.

\subsection{Поддержка разработчика}
Разработчики движка \mintinline{C++}{Construct} 2 ещё поддерживают и обновляют движок, также недавно они выпустили новую версию \mintinline{C++}{Construct} --- \mintinline{C++}{Construct} 3. На данный момент нововведений в новой версии не так много и инструментарий последних версий не имеет значительных различий между собой. Однако выпуск нового движка означает, что \mintinline{C++}{Construct} 2 в скором времени не будет получать новые обновления от разработчиков.\cite{gd_const}

Поддержка \mintinline{C++}{Unity} продолжается и сам движок получает обновления довольно часто, но при каждой новой версии требуется скачивание и установка нового движка с нуля. Также каждая новая версия иногда не имеет значительных изменений, но в другой версии могут ввести новые возможности для разработчиков, и в месте с ней появляются новые баги, которые не известно сколько будут чинить, ещё новая версия может изменить работу старого функционала тем самым проект может перестать работать, и подстройка под новый функционал может занять много времени и сил. Тем самым постоянная поддержка движка может как положительно повлиять на разработку так и полностью испортить идеально работающую программу.\cite{Pcgamer}
\newpage
\section{Разработанная игра}
\subsection{Реализация на Construct 2}
Для разработки игры на \mintinline{C++}{Construct} 2 и \mintinline{C++}{Unity} был выбран жанр платформер в двухмерном пространстве.

При первом запуске программы был создан стартовый экран с указанием клавиш управления. Вид стартового экрана приведён на рисунке ~\ref{fig:Const-starting}. Для реализации экрана был использован новый макет включающий в себя объект типа \mintinline{C++}{sprite} для отображения заднего рисунка и три объекта типа \mintinline{C++}{text} для отображения текста с клавишами управления. 

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.5]{Construct_starting.png}
    \caption{Стартовый экран}\label{fig:Const-starting}
\end{figure}

Для реализации смены экрана был подключён объект типа \mintinline{C++}{keyboard} для считывания нажатия клавиши на клавиатуре. Также на листе событий было добавлено событие, которое при нажатии на любую клавишу клавиатуры производило переход на новый макет с листом событий. Событие представлено на рисунке ~\ref{fig:Const-startevent}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_startevent.png}
    \caption{Событие смены макета с листом событий}\label{fig:Const-startevent}
\end{figure}

После смены открываются макет и лист событий, в которых создан игровой уровень. Вид уровня представлен на рисунке ~\ref{fig:Const-game}. В макете используется 13 объектов взаимодействующих с игроком, 2 объекта типа sprite для отображения заднего фона --- \mintinline{C++}{Back} и карты уровня --- \mintinline{C++}{Tiles}, и объект типа \mintinline{C++}{keyboard} для считывания нажатия клавиши на клавиатуре .

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{Construct_game.png}
    \caption{Игровой уровень}\label{fig:Const-game}
\end{figure}

Для перемещения игрока используется объект \mintinline{C++}{Pluer} типа \mintinline{C++}{sprite} с поведением \mintinline{C++}{platform} для определения управления игрока. В текущем уровне были изменены параметры поведения \mintinline{C++}{platform}, изменена максимальная скорость игрока, сила пражка, возможность двойного прыжка и отключены предустановленные клавиши управления. Все параметры игрока представлены на рисунке ~\ref{fig:Const-pluer}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{Construct_pluer.png}
    \caption{Параметры игрока}\label{fig:Const-pluer}
\end{figure}

Для перемещения игрока влево создано событие, которые при нажатии клавиши \mintinline{C++}{A} производит симуляцию перемещения влево с помощью возможностей движка и переворот модели игрока для отображения того, что он направлен в левую сторону. Аналогичный процесс для перемещения игрока вправо, только для клавиши \mintinline{C++}{D} и игрок отображается не перевёрнутым. Для реализации прыжка происходит событие, которое производит симуляцию прыжка при нажатии клавищи \mintinline{C++}{Space}. События представлено на рисунке ~\ref{fig:Const-control}. Также чтобы игрок не проходил сквозь стены объекту \mintinline{C++}{Tiles} было добавлено поведение \mintinline{C++}{solid}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_control.png}
    \caption{События управления игрока}\label{fig:Const-control}
\end{figure}

При перемещении игрок также меняет свою анимации для более приятной игры. Смена анимации происходит с помощью событий сравнивающих текущее состояние игрока и устанавливающее текущую анимацию в зависимости от него. Если игрок перемещается по земле то устанавливается анимация бега, если не двигается на земле то анимация бездействия, если прыгает то прыжка, если падает то падения. События приведены на рисунке ~\ref{fig:Const-switchanim}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_switchanim.png}
    \caption{Смена анимации игрока}\label{fig:Const-switchanim}
\end{figure}

Во время игры дополнительной задачей игрока является сбор монет, которые являются объектом типа sprite. При взаимодействии с монетой игрок получает одно очко и монета исчезает, это реализовано с помощью события, которое при прохождении игрока через монету уничтожает объект монеты и увеличивает глобальную переменную \mintinline{C++}{Points} на единицу. Событие приведено на рисунке ~\ref{fig:Const-coin}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_coin.png}
    \caption{Подбор монеты}\label{fig:Const-coin}
\end{figure}


\newpage

Первой опасностью для игрока являются объекты \mintinline{C++}{Spikes} и \mintinline{C++}{Fire}, которые имеют тип \mintinline{C++}{Sprite}. При взаимодействии с ними игрок погибает и начинает уровень сначала. Смерть игрока реализована с помощью двух событий, которые при прохождении игрока через объект \mintinline{C++}{Spikes} или \mintinline{C++}{Fire} уничтожают объект игрока, с которым произошло взаимодействие. События приведены на рисунке ~\ref{fig:Const-deathstatic}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_deathstatic.png}
    \caption{Взаимодействие игрока с объектами \mintinline{C++}{Spikes} и \mintinline{C++}{Fire}}\label{fig:Const-deathstatic}
\end{figure}

При смерти игрока происходит перезагрузка уровня, она реализована с помощью события, которое при уничтожении объекта \mintinline{C++}{Pluer} перезапускает текущий макет и обнуляет глобальную переменную \mintinline{C++}{Points} Событие приведено на рисунке ~\ref{fig:Const-deth}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_deth.png}
    \caption{Перезапуск при смерти игрока}\label{fig:Const-deth}
\end{figure}

Опасность для игрока также представляют ловушки стреляющие стрелами раз в секунду, ловушки и стрелы являются объектами типа \mintinline{C++}{sprite}, но ловушки имеют в себе дополнительную переменную \mintinline{C++}{Enabled} означающую её включенность. Стрельба реализована с помощью события, которое создаёт стрелу каждую секунду создаёт стрелу в позиции при каждой ловушке, если она включена. Событие приведено на рисунке ~\ref{fig:Const-shot}. Включение происходит с помощью вспомогательного объекта \mintinline{C++}{trigger} типа \mintinline{C++}{sprite}, оно реализовано событием, которое изменяет переменную \mintinline{C++}{Enabled} и анимацию во всех ловушках при пересечении игрока и \mintinline{C++}{trigger}. Событие приведено на рисунке ~\ref{fig:Const-trigger}. Стрела также имеет поведение \mintinline{C++}{bullet}, которое заставляет стрелу передвигаться с постоянной скоростью. Стрела имеет события, которые при создании стрелы перемещают её на слой объектов, при столкновении стрелы со стеной уничтожают её и при столкновении с игроком уничтожают игрока и стрелу. События приведены на рисунках ~\ref{fig:Const-create}, ~\ref{fig:Const-wall} и ~\ref{fig:Const-pluerarrow}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_shot.png}
    \caption{Стрельба ловушек}\label{fig:Const-shot}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_trigger.png}
    \caption{Включение ловушек}\label{fig:Const-trigger}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_create.png}
    \caption{Перемещение стрелы при создании}\label{fig:Const-create}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_wall.png}
    \caption{Соприкосновение стрелы со стеной}\label{fig:Const-wall}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_pluerarrow.png}
    \caption{Соприкосновение стрелы с игроком}\label{fig:Const-pluerarrow}
\end{figure}

Последней опасностью для игрока является передвигающийся противник. Он представляет собой объект типа \mintinline{C++}{sprite} с поведением \mintinline{C++}{platform} и переменными направления и включенности. Перемещение реализовано с помощью события, которое производит перемещение влево или вправо в зависимости от значения переменной направления, потом происходит проверка на то, что противник не будет идти в стену или упадёт с платформы, если проверка неудачная то противник будет развёрнут в обратную сторону. Противник будет включён при первом попадании на экран, и при столкновении с игроком, игрок будет уничтожен. Все события приведены на изображении ~\ref{fig:Const-enemy}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_enemy.png}
    \caption{События противника}\label{fig:Const-enemy}
\end{figure}

Концом уровня считается момент когда игрок достигает выхода. При соприкосновении игрока с выходом вызывается событие меняющее текущий макет и лист событий. При переключении устанавливается значение, равное количеству собранных монет, в текстовый объект. События выполняющие эти действия представлены на рисунках ~\ref{fig:Const-exit} и ~\ref{fig:Const-coincount}. Вид финального экрана представлен на рисунке ~\ref{fig:Const-fin}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_exit.png}
    \caption{Выход с уровня}\label{fig:Const-exit}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_coincount.png}
    \caption{Установка количества собранных монет}\label{fig:Const-coincount}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_fin.png}
    \caption{Финальный экран}\label{fig:Const-fin}
\end{figure}

Полный вид проекта представлен в приложении ~\ref{const-add}
\newpage

\subsection{Реализация на Unity}
При первом запуске открывается стартовый экран идентичный по виду реализованному на \mintinline{C++}{Construct}. Стартовый экран изображён на на рисунке ~\ref{fig:Const-starting}. Для его изображения используется объект, который находится на объекте со свойством \mintinline{C++}{grid}, со свойствами \mintinline{C++}{tilemap} и \mintinline{C++}{tilemap renderer} для отображения фона стартового экрана, и объект, который находиться на объекте с компонентами \mintinline{C++}{canvas, canvas scaler} и \mintinline{C++}{graphic raycaster}, с компонентами \mintinline{C++}{canvas renderer} и \mintinline{C++}{text} для отображения текста с управлением. Для того чтобы убрать стартовый экран используется скрипт находящийся в объекте \mintinline{C++}{Pluer}. В скрипте находиться переменные являющиеся объектами отвечающими за стартовый экран и переменная означающая начальный ли экран сейчас. При выполнении скрипта во время нажатия любой кнопки объекты отвечающие за стартовый экран становятся неактивными, тем самым исчезая с поля зрения игрока, и переменная начального экрана изменяет значение на противоположное. Функции для выключения стартового экрана выглядят следующим образом:

\begin{minted}[fontsize=\small]{c++}
    uistart.SetActive(false);
    startScreen.SetActive(false);
\end{minted}

Игрок управляет объектом \mintinline{C++}{Pluer} со свойствами \mintinline{C++}{Box Collider 2D} и \mintinline{C++}{Circle Collider 2D} для определения границ взаимодействия объекта, \newline \mintinline{C++}{Rigidbody 2D} для определения физических свойств объекта, \mintinline{C++}{Sprite Renderer} и \mintinline{C++}{Animator} для отображения объекта в виде статичного и динамичного изображения, последним свойством является скрипт отвечающий за управление пользователем персонажа. 

Основной частью скрипта является перемещение персонажа при нажатии клавиши. Для этого в скрипте объявлены переменные \mintinline{C++}{JumpForce},
\newline  \mintinline{C++}{MovementSmoothing, runSpeed} являющиеся настраемыми напрямую из движка и отвечающие за силу прыжка, сглаживание передвижения и скорость бега. Переменные \mintinline{C++}{FloorCheckRadius, FloorCheck, OnFloor, jump, diRight}, \mintinline{C++}{velocity, horMove, dead} отвечающие за радиус проверки стоит ли персонаж, точка относительно которой проходит проверка, стоит ли персонаж на земле, в воздухе ли он, направление по горизонтали, ускорение, скорость перемещения по горизонтали, жив ли персонаж. Эти переменные изменяются программно и не могут быть изменены вне редактора кода. Функция \mintinline{C++}{Start} определяет компонент \mintinline{C++}{RigidBody2D} принадлежащий игроку, потом если персонаж жив в функции \mintinline{C++}{Update} происходит проверка на нажатие клавиш, в функции \mintinline{C++}{FixedUpdate} происходит реакция на нажатие клавиш вызывая функции \mintinline{C++}{floorCheck}, отвечающую за проверку на земле ли игрок, \mintinline{C++}{Flip}, переворачивает систему координат игрока по горизонтали, и \mintinline{C++}{Move}, отвечающую за изменение текущей скорости игрока. При выполнении функции \mintinline{C++}{floorCheck} происходит предположение что игрок не находится на земле, после этого происходит проверка нахождения земли в радиусе \mintinline{C++}{FloorCheckRadius} относительно точки \mintinline{C++}{FloorCheck}, при наличии земли устанавливается что игрок на земле. Функция \mintinline{C++}{Move} изменяет вектор скорости игрока равный заданной скорости до тех пор пока она не достигнет требуемого значения. Функции \mintinline{C++}{FloorCheck} и \mintinline{C++}{Move} выглядят следующим образом:

\begin{minted}[fontsize=\small]{c++}
 
     private void floorCheck()
     {
         bool onfloor = OnFloor;
         OnFloor = false;
     
         Collider2D[] colliders = Physics2D.OverlapCircleAll(FloorCheck.position, 
             FloorCheckRadius, Ground);
         for (int i = 0; i < colliders.Length; i++)
             {
             if (colliders[i].gameObject != gameObject)
             {
                 OnFloor = true;
             }
         }
     }
     
     private void Move(float move, bool jump)
     {
         Vector3 targetVelocity = new Vector2(move * 10f, myRigidbody2D.velocity.y);
         myRigidbody2D.velocity = Vector3.SmoothDamp(myRigidbody2D.velocity, 
         targetVelocity, ref velocity, MovementSmoothing);
     }
 \end{minted}

Для определения какой вид анимации должен быть проигран в данный момент определяется с помощью энумератора \mintinline{C++}{State}, который включает в себя все возможные состояния, переменной \mintinline{C++}{curState}, указывающей на текущее состояние, и компонента \mintinline{C++}{Animator}, который позволяет изменять порядок анимации. Функция \mintinline{C++}{Start} определяет компонент \mintinline{C++}{Animator}, принадлежащий игроку, функция \mintinline{C++}{Update} изменяет положение на прыжок при нажатии клавиши отвечающей за прыжок, функция \mintinline{C++}{FixedUpdate} вызывает функцию \mintinline{C++}{StateChanger}, которая отвечает за изменение переменной \mintinline{C++}{curState}, и изменяет значение состояния внутри компонента \mintinline{C++}{Animator}. Код отвечающий за изменение анимации представлен ниже:

\begin{minted}[fontsize=\small]{c++}
     private void StateChanger()
     {
         switch (curState)
             {
             case State.jump:
             {
                  if (myRigidbody2D.velocity.y < -0.001f) curState = State.fall;
             }
             break;
             case State.fall:
             {
                  if (OnFloor) curState = State.idle;
             }
             break;
             default:
             {
                  if (Mathf.Abs(myRigidbody2D.velocity.x) > 1f)
                  {
                       curState = State.run;
                  }
                  else
                  {
                       curState = State.idle;
                  }
                  if (myRigidbody2D.velocity.y < -0.001f && !OnFloor) 
                       curState = State.fall;
             }
             break;
             }
     }
 \end{minted}
 
Шипы, огонь, стрелы и противник являются сущностями с тэгом \mintinline{C++}{DETH}. С этим тэгом персонаж может понять с как взаимодействовать при соприкосновении или прохождении сквозь объект с тэгом. При тэге \mintinline{C++}{DETH} игрок будет считаться погибшим, для этого используются переменные \mintinline{C++}{dead} и \mintinline{C++}{curState}, для определения смерти и возрождения персонажа. Функция \mintinline{C++}{Start} определяет компонент \mintinline{C++}{Animator}, принадлежащий игроку, функция \mintinline{C++}{OnCollisionEnter2D} происходит при соприкосновении, \mintinline{C++}{OnTriggerEnter2D} происходит при прохождении, обе функции изменяют состояние и анимацию. Эти функции представлены ниже:

\begin{minted}[fontsize=\small]{c++}
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (!dead)
            switch (collision.gameObject.tag)
            {
                case "DETH":
                {
                    dead = true;
                    curState = State.deth;
                    myRigidbody2D.velocity = new Vector3(0, 0, 0);
                    anime.SetInteger("AnimeState", (int)curState);
                }break;
                default:
                {
                }break;
            }
    }
    
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (!dead)
            switch (collision.gameObject.tag)
             {
                case "DETH":
                {
                    dead = true;
                    curState = State.deth;
                    myRigidbody2D.velocity = new Vector3(0, 0, 0);
                    anime.SetInteger("AnimeState", (int)curState);
                }break;
                default:
                {
                }break;
             }
    }
 \end{minted}

За воскрешение игрока отвечают функции \mintinline{C++}{SpawnStart} и \mintinline{C++}{SpawnEnd}. В этих функциях используются компонент \mintinline{C++}{Animator} для изменения анимации, \mintinline{C++}{disabler} для выключения ловушек, \mintinline{C++}{transform} для изменении позиции игрока, \mintinline{C++}{Camera} для изменения камеры. \mintinline{C++}{SpawnStart} вызывается при конце анимации смерти игрока и изменяет положение игрока в стартовую точку с нулевой скоростью, в эту же точку перемещается камера, и изменяется анимация на воскрешение. \mintinline{C++}{SpawnEnd} вызывается после анимации воскрешения и снова включает управление игроку.

\begin{minted}[fontsize=\small]{c++}
public class PluerMovement : MonoBehaviour
{
    private void SpawnStart()
    {
        curState = State.spawn;
        Camera.position = new Vector3(13.63f, -0.4199999f, -10f);
        transform.position = SpawnPoint.position;
        myRigidbody2D.velocity = Vector3.zero;
        Animator disabler = LeftShooter.GetComponent<Animator>();
        disabler.SetBool("Enabled", false);
        disabler = RightShooter.GetComponent<Animator>();
        disabler.SetBool("Enabled", false);
        anime.SetInteger("AnimeState", (int)curState);
    }
    
    private void SpawnEnd()
    {
        dead = false;
        Camera.position = new Vector3(13.63f, -0.4199999f, -10f);
        curState = State.idle;
        anime.SetInteger("AnimeState", (int)curState);
    }
}
 \end{minted}

Стрельба происходит в сущности \mintinline{C++}{Shooter}, включающей в себе скрипт с функцией включения и выстрела. Функция включения активируется при прохождении игроком положения триггера, функция стрельбы же активируется с помощью события вызываемого в конце включенной анимации и создающих стрелы в точках создания. Код этих функций представлен ниже:
\begin{minted}[fontsize=\small]{c++}
    private void Shoot()
    {
        Instantiate(Arrow, SpawnPoint.position, SpawnPoint.rotation);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            Enabled = true;
            Anime.SetBool("Enabled", Enabled);
        }
    }
 \end{minted}

При создании стрел в зависимости от переменной \mintinline{C++}{isRight} устанавливается скорость и направление, в котором летит стрела. Стрелы используют скрипты для изменения состояния на сломанную, и уничтожения стрелы. При прохождения сквозь стену или игрока функция \mintinline{C++}{OnTriggerEnter2D} стрела становится сломанной и начинает падать вниз. Функция \mintinline{C++}{EndArrow} вызывается после прохождения 0.05 секунд после вызова \mintinline{C++}{OnTriggerEnter2D}. Код этих функций представлен ниже:

\begin{minted}[fontsize=\small]{c++}
    private void OnTriggerEnter2D(Collider2D collision)
    {
        switch (collision.gameObject.tag)
        {
            case "Ground":
                {
                    myrb.velocity = new Vector2(0, -0.5f);
                    myrb.gravityScale = 1;
                    anime.SetBool("Broken", true);
                }
                break;
            case "Player":
                {
                    myrb.velocity = new Vector2(0, -0.5f);
                    myrb.gravityScale = 1;
                    anime.SetBool("Broken", true);
                }
                break;
        }
    }
    private void EndArrow()
    {
        Destroy(gameObject);
    }
 \end{minted}

Подбор монет осуществляется с помощью скрипта в сущности \mintinline{C++}{Pluer} и скрипта в сущности \mintinline{C++}{Coin}. Скрипт в \mintinline{C++}{Player} изменяет количество собранных монет и состояние монеты. Скрипт монет имеет только функцию \mintinline{C++}{EndSparkle}, которая уничтожает монету при конце анимации сбора. Код функций представлен нижу:
\begin{minted}[fontsize=\small]{c++}
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (!dead)
            switch (collision.gameObject.tag)
            {
                ...
                case "Coin":
                {
                    counter.text = coinCount.ToString();
                    Animator animeCoin = 
                        collision.gameObject.GetComponent<Animator>();
                    if(!animeCoin.GetBool("Collected")) coinCount++;
                    animeCoin.SetBool("Collected", true);
                }break;
                ...
            }
		}
				
		void EndSparkle()
    {
        Destroy(gameObject);
    }
 \end{minted}

Противник использует собственный скрипт для определения перемещения. Он включает в себя переменные и компоненты \mintinline{C++}{FloorPoint, isRight, speed, checkRadius, Ground, myrb} отвечающие за тоже что и в \mintinline{C++}{Pluer}. \mintinline{C++}{Start} определяет компонент \mintinline{C++}{myrb} и первоначальное ускорение, \mintinline{C++}{Update} изменяет ускорение, \mintinline{C++}{FixedUpdate} определяет направление. \mintinline{C++}{FixedUpadate} использует тот же алгоритм что и \mintinline{C++}{floorCheck} у игрока. Код функций \mintinline{C++}{Start} и \mintinline{C++}{Update} представлен ниже:
\begin{minted}[fontsize=\small]{c++}
    void Start()
    {
        myrb = GetComponent<Rigidbody2D>();
        if (isRight) myrb.velocity = new Vector2(speed, 0);
        else myrb.velocity = new Vector2(-speed, 0);
    }

    // Update is called once per frame
    void Update()
    {
        if (isRight) myrb.velocity = new Vector2(speed, 0);
        else myrb.velocity = new Vector2(-speed, 0);
    }
\end{minted}

При прохождении игроком выхода функция \mintinline{C++}{OnTriggerEnter2D} показывает финальный экран идентичный реализованному в \mintinline{C++}{Construct}. Изменения происходящие при конце уровня представлены ниже:
\begin{minted}[fontsize=\small]{c++}
    endgame = true;
    uiend.SetActive(true);
    endScreen.SetActive(true);
    curState = State.idle;
    myRigidbody2D.velocity = Vector3.zero;
    transform.position = new Vector3(39.02f, 23.25f, 0f);
    anime.SetInteger("AnimeState", (int)curState);
    dead = true;
\end{minted}
Полный код проекта представлен в приложении ~\ref{unity-add}.

\conclusion
Итогом можно считать, что \mintinline{C++}{Construct} в следствие своей простоты позволяет создавать несложные игры без усилий, благодаря этому его лучше использовать чтобы попытаться быть игровым разработчиком или научится самым базовым навыкам разработки. \mintinline{C++}{Unity} благодаря своему масштабу и возможностям, подходит как для маленьких начинающих компаний так и для крупных компаний. 
%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix
\section{Проект на Construct 2}\label{const-add}
Весь проект на \mintinline{C++}{Construct} 2 представлен на отдельном CD-носителе. 
\section{Код проекта на Unity}\label{unity-add}
Скрипт объекта Pluer
\inputminted[fontsize=\small,encoding=utf8,outencoding=cp1251]{C++}{PluerMovement.cs}
Скрипт объекта Enemy
\inputminted[fontsize=\small,encoding=utf8,outencoding=cp1251]{C++}{EnemyMovement.cs}
Скрипт объекта Shooter
\inputminted[fontsize=\small,encoding=utf8,outencoding=cp1251]{C++}{ShooterScript.cs}
Скрипт объекта Arrow
\inputminted[fontsize=\small,encoding=utf8,outencoding=cp1251]{C++}{ArrowScript.cs}
Скрипт объекта Coin
\inputminted[fontsize=\small,encoding=utf8,outencoding=cp1251]{C++}{CoinScript.cs}
\end{document}