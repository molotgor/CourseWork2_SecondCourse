\documentclass[bachelor, och, coursework, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Сравнение игровых движков Unity и Construct 2}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Яшина Егора Александровича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{А.\,С.\,Иванова}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
%\patitle{к.\,ф.-м.\,н., доцент}
%\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
%\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
%\practStart{01.07.2016}
%\practFinish{14.07.2016}

% Год выполнения отчета
\date{2020}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе


% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
В современном мире немалую часть рынка развлечений занимают игры, каждая из них создана на своем игровом движке. Игровых движков в мире также имеется достаточное количество, и при выборе нужного разработчик может подобрать под свои нужды и желания. Но как же определить нужный движок? В данной курсовой работе будут сравнены движки Construct 2 и Unity, и на разработанных примерах будет определенно предпочитаемая область разработки на этих движках.

\section{Обзор возможностей игровых движков}
\subsection{Construct 2}
Construct 2 является движком, основанным на HTML5 и позволяющим создавать двухмерные игры. Отличительной особенностью движка Construct является полное отсутствие кода, вместо него используются события. Событие --- это логическое ветвление, состоящее из условия, которое может быть создано с помощью конструкций <<И>>, <<Или>>, и действия, которое может включать в себя как набор последовательных команд так и одиночную команду.

Проект в Construct разделяется на макеты и листы событий. Макет представляет собой рабочую область в которой располагаются игровые объекты. Макет имеет собственные параметры такие как название, размер видимой рабочей области, лист событий который работает в данном макете.\cite{gd_html5} Макет пустого проекта представлен на рисунке ~\ref{fig:Const-workplaces}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.39]{Construct_workplace.png}
    \caption{Макет пустого проекта}\label{fig:Const-workplaces}
\end{figure}

При создании нового объекта, выбирается тип объекта, которым он является, и в зависимости от типа будут определенны параметры и события доступные данному элементом. Все возможные типы объектов приведены на рисунке ~\ref{fig:Construct_objects}. Для включения определенных средств ввода нужно добавление объекта с типом требуемого средства ввода. \cite{gd_html5}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{Construct_objects.png}
    \caption{Все типы объектов}\label{fig:Construct_objects}
\end{figure}

Для большинства типов объектов можно добавить новые параметры и возможности с помощью поведения объекта. Все возможные поведения приведены на рисунке ~\ref{fig:Const-behav}. Поведение объекта является еще одним важным элементом Construct, поведение задает шаблоны действий объекта в зависимости от параметров поведения. К примеру поведение платформ представляет собой готовый объект игрока для игрового жанра платформер, в данном жанре основными действиями является перемещение и прыжок, поведение платформ предоставляет возможность настроить скорость перемещения и прыжка, также устанавливается базовое управление на клавиши влево и вправо движение в соответствующие стороны и на клавишу вверх устанавливается прыжок.\cite{gd_const}

\newpage

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_behaviors.png}
    \caption{Все поведения объекта}\label{fig:Const-behav}
\end{figure}

Construct предоставляет инструменты для создания новых объектов, требующих графическое изображение, внутри движка. Так при создании нового объекта типа спрайта открывается графический редактор который, позволяет нарисовать новое изображение в движке либо загрузить уже существующее, позволяет настроить границы соприкосновения объекта и исходную точку, также внутри редактора можно настроить анимации объекта и их количество. Пример редактора приведён на рисунке ~\ref{fig:Construct_paint}.
\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_paint.png}
    \caption{Все поведения объекта}\label{fig:Construct_paint}
\end{figure}

\newpage

Лист событий представляет собой последовательное расположение всех событий проекта. Пример листа событий приведен на рисунке ~\ref{fig:Const-eventsheet}. Для добавления нового события на листе событий выбирается объект и условие допустимое движком, после этого выбирается другой или уже выбранный объект и допустимое движком действие с этим объектом. Примером может являться перемещение персонажа влево при нажатии клавиши A, для этого проект должен включать объект типа клавиатуры для считывания нажатой клавиши и объект типа платформер для создания перемещения. Как логическое условие берется нажатие клавиши A, действием будет являться симуляция передвижения влево. Вид этого события приведён на рисунке ~\ref{fig:Const-eventsheet}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.4]{Construct_eventsheet.png}
    \caption{Лист событий}\label{fig:Const-eventsheet}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_eventexample.png}
    \caption{Пример события}\label{fig:Const-eventexample}
\end{figure}

\newpage

Construct является проприетарным движком. Он имеет бесплатную версию с ограничениями, то есть отсутствуют функции и возможность коммерческого использования, также имеется лимит по количеству событий. Существует две платные версии: одна для бизнеса другая для персонального использования. Все отличия бесплатной версии от платных представлены в таблице ~\ref{tab:Const-versions}.  Различия в функционале этих версий отсутствуют в них присутствуют все возможные функции без ограничений, но существует условие что персональную версию нельзя использовать после заработанных 5000\$ с помощью этого движка. Соответственно платные версии отличаются в цене 200\$ за персональную версию и 500\$ за бизнес.\cite{Constr_of} 

\begin{table}[!ht]
    \small
    \caption{Отличия в лицензиях Construct 2}\label{tab:Const-versions}
    \begin{tabular}{|l|l|l|}\hline
    Характеристика & Бесплатная лицензия & Платные лицензии\cr\hline
    Вкладка просмотра отладчика & Отсутствует & Присутствует\cr\hline
    Профайлер & Отсутствует & Присутствует\cr\hline
    Точки остановки для event	 & Отсутствует & Присутствует\cr\hline
    
    Создание iOS приложений	 & Отсутствует & Присутствует\cr\hline
    Создание Android приложений	 & Отсутствует & Присутствует\cr\hline
    Создание Windows приложений	 & Отсутствует & Присутствует\cr\hline
    Создание Mac приложений & Отсутствует & Присутствует\cr\hline
    Создание Linux приложений	 & Отсутствует & Присутствует\cr\hline
    Создание Amazon Store приложений	 & Отсутствует & Присутствует\cr\hline
    Создание игр для Wii U 	 & Отсутствует & Присутствует\cr\hline
    Внутриигровые покупки		 & Отсутствует & Присутствует\cr\hline
    
    Максимальное количество событий	 & 100 & Неограниченно \cr\hline
    Максимальное количество сцен	 & 4 & Неограниченно\cr\hline
    Максимальное количество особых эффектов & 2 & Неограниченно\cr\hline
    Подпапки проекта	 & Отсутствует & Присутствует\cr\hline
    Поиск событий	 & Отсутствует & Присутствует\cr\hline
    Панель расположения z"=порядка	 & Отсутствует & Присутствует\cr\hline    
    Семейства объектов	 & Отсутствует & Присутствует\cr\hline
    Мгновенный просмотр	 & Отсутствует & Присутствует\cr\hline
    \end{tabular}
\end{table}

\newpage

\subsection{Unity}
Unity является игровым движком который позволяет создавать как двухмерные так и трехмерные игры. Особенностью Unity является то что все объекты являются сущностями. Сущность --- это представление любого объекта, который может быть представлен в игре. Сущностью могут являться медиа файлы принадлежащие проекту, файлы созданные Unity, скрипты. 

Проект в Unity представляет безграничную рабочую область, в которой расставляются все игровые объекты задействованные в данной сцене. Рабочая область использует собственные значения для определения размера объекта внутри себя называемые юнитами, в следствии этого при загрузке нового графического файла требуется указать сколько пикселей будет внутри 1 юнита. В рабочей области можно располагать объекты как в трехмерном так и в двухмерном пространстве.\cite{gd_unity}  Unity позволяет производить переключение между пространствами в любой момент разработки проекта, это позволяет определить расположение объектов относительно друг друга в разработке двухмерных игр, и позволяет производить разработку игр со смешанным пространством.\cite{gd_unity_2d} Пример расположения двухмерных объектов в трехмерном пространстве приведен на рисунке ~\ref{fig:Unity-zlayers}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{Unity_zlayers.png}
    \caption{Расположение двухмерных объектов в трехмерном пространстве}\label{fig:Unity-zlayers}
\end{figure}

Любой игровой объект представленный в рабочей области обладает компонентом tranform, то есть компонентом которое определяет положение объекта внутри сцены. Для отображения и взаимодействия объекта с другими объектами требуется добавить новые компоненты. К примеру для отображения используется компонент sprite renderer которое производит рендер изображения с параметрами свойства transform, физические свойства объекта определяются самим движком и инициализируются компонентами rigidbody2d или rigitbody в зависимости от требуемого пространства. Пример объекта с несколькими компонентами представлен на рисунке ~\ref{fig:Unity-components}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.6]{Unity_components.png}
    \caption{Объект с несколькими компонентами}\label{fig:Unity-components}
\end{figure}

\newpage

Animator является свойством требуемым для отображения анимации, Unity имеет инструменты для создания новых анимаций и создание условий перехода между разными видами анимаций. Для создания новой анимации достаточно создать пустую анимацию и добавить её к объекту, после этого для добавления новых кадров нужно перенести графические файлы в поле анимации, также анимация может иметь вызов функции по достижению определённого времени внутри себя. \cite{gd_unity} Пример анимации на рисунке ~\ref{fig:Unity-animation}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.6]{Unity_animation.png}
    \caption{Анимация в Unity}\label{fig:Unity-animation}
\end{figure}

Переход анимаций в Unity может происходить  при определённом условии, animator может включать в себя переменные типов bool, int, float, trigger и при достижении нужного состояния переменных для смены анимации произойдёт смена на новую анимацию с первого кадра. Каждый переход будет отображаться стрелочкой направляющей в анимацию, в которую будет осуществлен переход. Пример Animator с переходами анимаций представлен на  рисунке ~\ref{fig:Unity-animatorchange}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.6]{Unity_animatorchange}
    \caption{Animator с переходами анимаций}\label{fig:Unity-animatorchange}
\end{figure}

Для изменения параметров свойств объектов программным путём используются скрипты. В Unity скрипты могут быть написаны как на C\# --- Unity Scripting Api\cite{MSDN} так и на JavaScript --- UnityScript. Пустой скрипт включает в себя библиотеки требуемые для написания на языке Unity, и две функции Start и Update. Start перед первым кадров. Функция Update вызывается в проекте каждый кадр.\cite{gd_unity_c} Пустой скрипт на C\# выглядит так:

\begin{Verbatim}[fontsize=\small, numbers=left]
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
\end{Verbatim}
Форма распространения Unity является проприетарной. Видов подписок четыре: Personal, Plus, Pro, Enterprise. Все подписки доступны для коммерческого использования но имеется ограничение по годовому заработку пользователя определенной лицензии.  Различия подписок еще заключаются в возможностях при разработке приложения.\cite{Gamesparks} Все отличия подписок представлены в таблице ~\ref{tab:Unity-subsr}.

\begin{table}[!ht]
    \small
    \caption{Отличия в подписках Unity}\label{tab:Unity-subsr}
    \begin{tabular}
     %\multicolumn{5}{|l|}{V-В СОСТАВе X-НЕ ВХОДИТ В СОСТАВ +-ДОСТУПНО ЗА ДОПОЛНИТЕЛЬНУЮ ПЛАТУ}
    {|p{7.3cm}|l|l|l|l|}\hline
    \multicolumn{5}{|l|}{V --- в состае, X --- не входит в состав, + --- доступно за дополнительную плату}\cr\hline
    Характеристика & Personal & Plus & Pro & Enterprise\cr\hline
    Ограничения по годовому заработку  & $\leqslant$ 100000\$ & $\leqslant$ 200000\$& > 200000\$ & > 200000\$ \cr\hline
    Pro Editor UI & X & V & V & V\cr\hline
    Управление заставочным экраном & X & V & V & V\cr\hline
    Пакет графических ресурсов высокого разрешения & X & X & V & V\cr\hline
    Доступ к исходному коду  & X & X& + & + \cr\hline
    Специальные отраслевые решения & X & X & X & +\cr\hline
    Advanced Cloud Diagnostics & X & V & V & V\cr\hline
    Основная аналитика & X & V & V & V\cr\hline
    Analytics: 50 ГБ экспорта необработанных данных в месяц & X & X & V & V\cr\hline
    Доступ к Unity Learn Premium & + & V & V & V\cr\hline
    Приоритетный доступ к консультантам по успеху Unity & X & X & V & V\cr\hline
    Приоритетная очередь клиентской поддержки & X & X & V & V\cr\hline
    Premium Support & X & X & + & +\cr\hline
    Встроенные услуги Success Service & X & X & X & +\cr\hline
    Стоимость в месяц & Бесплатно & 40\$ & 150\$ & Гибкая цена\cr\hline
    \end{tabular}
\end{table}

Также существует вариант студенческой подписки для этого студент должен иметь возраст, юридически достаточный для согласия на сбор и обработку персональных данных, и быть зарегистрированным в GitHub Student Developer Pack. Эта подписка является бесплатной и предоставляет возможности который в обычной нет. Этими возможностями являются неограниченный доступ к Learn Premium, пять рабочих мест в Unity Teams Advanced, темная тема пользовательского интерфейса и диагностика реального времени в облаке.\cite{Unity_of}
\section{Сравнение движков}


\subsection{Сложность}
При знакомстве с новым движком пользователь может запутаться в его строении и сделать решение сменить среду разработки.

Хоть в Unity большинство скриптов пишется на C\#, который проще чем C++, и сам движок предоставляет возможность создать все, что разработчик может себе представить. Но именно множество возможностей и ошеломляет нового пользователя, который не знает с чего лучше начать изучение. Unity предоставляет бесплатные обучающие уроки, однако в большом количестве информации очень легко запутаться, особенно если материал затрагивает темы не изученные пользователем. С другой стороны за всё время существования Unity было создано глобальное сообщество разработчиков, с его помощью можно найти требуемый материал если не на родном языке то на английском точно. Из-за сложности в начале разработки происходит ограничения для людей, которые не знают основ требуемых для создания нового проекта.\cite{gd_unity}

Construct является движком, который значительно проще Unity, это добивается отсутствием кода. Использование поведения объектов и событий сокращает код используемый в скриптах на Unity до одного события. Они как и поведения будут понятны почти каждому, построение нового события может быть переводом простого предложения в логическое высказывания. Эти возможности позволяют разработку на Construct почти каждому человеку.

\subsection{Занимаемая память и скорость запуска}
При установке движков иногда может возникнуть вопрос доступной памяти для него. И Constuct с Unity имеют значительную разницу в весе на диске. Construct не требует дополнительных установок кроме самой версии движка которая занимает около 120МБ. Unity же рекомендует установить программу для управлением версиями и проектами называемую --- Unity Hub, которая занимает  почти 200МБ, в то время сама версия Unity весит около 6.5 ГБ.

Следовательно из-за разности веса эти движки имеют совсем разное время запуска. В то время как Construct в среднем за несколько секунд и можно сразу же заниматься разработкой, Unity может запускать пустой проект в течении нескольких минут.

\subsection{Поддерживаемые платформы}
В Construct экпорт проекта происходить с помощью перевода на JavaScript. Тем самым разработчик может создать игру для платформ которые имеют поддержку Web.\cite{Gamesparks}

При установке Unity разработчик должен выбрать требуемые ему модули сборки проекта. Для движка существуют модули для любой платформы созданной на данный момент.

\subsection{Поддержка разработчика}
Разработчики движка Construct 2 ещё поддерживают и обновляют движок, также недавно они выпустили новую версию Construct --- Construct 3. На данный момент нововведений в новой версии не так много и инструментарий последних версий не имеет значительных различий между собой. Однако выпуск нового движка означает, что Construct 2 в скором времени не будет получать новые обновления от разработчиков.\cite{gd_const}

Поддержка Unity продолжается и сам движок получает обновления довольно часто, но при каждой новой версии требуется скачивание и установка нового движка с нуля. Также каждая новая версия иногда не имеет значительных изменений, но в другой версии могут ввести новые возможности для разработчиков, и в месте с ней появляются новые баги, которые не известно сколько будут чинить, ещё новая версия может изменить работу старого функционала тем самым проект может перестать работать, и подстройка под новый функционал может занять много времени и сил. Тем самым постоянная поддержка движка может как положительно повлиять на разработку так и полностью испортить идеально работающую программу.\cite{Pcgamer}
\newpage
\section{Разработанная игра}
\subsection{Реализация на Construct 2}
Для разработки игры на Construct 2 и Unity был выбран жанр платформер в двухмерном пространстве.

При первом запуске программы был создан стартовый экран с указанием клавиш управления. Вид стартового экрана приведён на рисунке ~\ref{fig:Const-starting}. Для реализации экрана был использован новый макет включающий в себя объект типа sprite для отображения заднего рисунка и три объекта типа text для отображения текста с клавишами управления. 

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.5]{Construct_starting.png}
    \caption{Стартовый экран}\label{fig:Const-starting}
\end{figure}

Для реализации смены экрана был подключён объект типа keyboard для считывания нажатия клавиши на клавиатуре. Также на листе событий было добавлено событие, которое при нажатии на любую клавишу клавиатуры производило переход на новый макет с листом событий. Событие представлено на рисунке ~\ref{fig:Const-startevent}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_startevent.png}
    \caption{Событие смены макета с листом событий}\label{fig:Const-startevent}
\end{figure}

После смены открываются макет и лист событий, в которых создан игровой уровень. Вид уровня представлен на рисунке ~\ref{fig:Const-game}. В макете используется 13 объектов взаимодействующих с игроком, 2 объекта типа sprite для отображения заднего фона --- Back и карты уровня --- Tiles, и объект типа keyboard для считывания нажатия клавиши на клавиатуре .

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{Construct_game.png}
    \caption{Игровой уровень}\label{fig:Const-game}
\end{figure}

Для перемещения игрока используется объект Pluer типа sprite с поведением platform для определения управления игрока. В текущем уровне были изменены параметры поведения platform, изменена максимальная скорость игрока, сила пражка, возможность двойного прыжка и отключены предустановленные клавиши управления. Все параметры игрока представлены на рисунке ~\ref{fig:Const-pluer}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{Construct_pluer.png}
    \caption{Параметры игрока}\label{fig:Const-pluer}
\end{figure}

Для перемещения игрока влево создано событие, которые при нажатии клавиши A производит симуляцию перемещения влево с помощью возможностей движка и переворот модели игрока для отображения того, что он направлен в левую сторону. Аналогичный процесс для перемещения игрока вправо, только для клавиши D и игрок отображается не перевёрнутым. Для реализации прыжка происходит событие, которое производит симуляцию прыжка при нажатии клавищи Space. События представлено на рисунке ~\ref{fig:Const-control}. Также чтобы игрок не проходил сквозь стены объекту Tiles было добавлено поведение solid.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_control.png}
    \caption{События управления игрока}\label{fig:Const-control}
\end{figure}

\newpage

При перемещении игрок также меняет свою анимации для более приятной игры. Смена анимации происходит с помощью событий сравнивающих текущее состояние игрока и устанавливающее текущую анимацию в зависимости от него. Если игрок перемещается по земле то устанавливается анимация бега, если не двигается на земле то анимация бездействия, если прыгает то прыжка, если падает то падения. События приведены на рисунке ~\ref{fig:Const-switchanim}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_switchanim.png}
    \caption{Смена анимации игрока}\label{fig:Const-switchanim}
\end{figure}

Во время игры дополнительной задачей игрока является сбор монет которые являются объектом типа sprite. При взаимодействии с монетой игрок получает одно очко и монета исчезает, это реализовано с помощью события, которое при прохождении игрока через монету уничтожает объект монеты и увеличивает глобальную переменную Points на единицу. Событие приведено на рисунке ~\ref{fig:Const-coin}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_coin.png}
    \caption{Подбор монеты}\label{fig:Const-coin}
\end{figure}


\newpage

Первой опасностью для игрока являются объекты Spikes и Fire, которые имеют тип Sprite. При взаимодействии с ними игрок погибает и начинает уровень сначала. Смерть игрока реализована с помощью двух событий которые при прохождении игрока через объект Spikes или Fire уничтожают объект игрока с которым произошло взаимодействие. События приведены на рисунке ~\ref{fig:Const-deathstatic}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_deathstatic.png}
    \caption{Взаимодействие игрока с объектами Spikes и Fire}\label{fig:Const-deathstatic}
\end{figure}

При смерти игрока происходит перезагрузка уровня, она реализована с помощью события, которое при уничтожении объекта Pluer перезапускает текущий макет и обнуляет глобальную переменную Points Событие приведено на рисунке ~\ref{fig:Const-deth}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_deth.png}
    \caption{Перезапуск при смерти игрока}\label{fig:Const-deth}
\end{figure}

Опасность для игрока также представляют ловушки стреляющие стрелами раз в секунду, ловушки и стрелы являются объектами типа sprite, но ловушки имеют в себе дополнительную переменную Enabled означающую её включенность. Стрельба реализована с помощью события, которое создаёт стрелу каждую секунду создаёт стрелу в позиции при каждой ловушке, если она включена. Событие приведено на рисунке ~\ref{fig:Const-shot}. Включение происходит с помощью вспомогательного объекта trigger типа sprite, оно реализовано событием, которое изменяет переменную Enabled и анимацию во всех ловушках при пересечении игрока и trigger. Событие приведено на рисунке ~\ref{fig:Const-trigger}. Стрела также имеет поведение bullet, которое заставляет стрелу передвигаться с постоянной скоростью. Стрела имеет события, которые при создании стрелы перемещают её на слой объектов, при столкновении стрелы со стеной уничтожают её и при столкновении с игроком уничтожают игрока и стрелу. События приведены на рисунках ~\ref{fig:Const-create}, ~\ref{fig:Const-wall} и ~\ref{fig:Const-pluerarrow}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_shot.png}
    \caption{Стрельба ловушек}\label{fig:Const-shot}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{Construct_trigger.png}
    \caption{Включение ловушек}\label{fig:Const-trigger}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_create.png}
    \caption{Перемещение стрелы при создании}\label{fig:Const-create}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_wall.png}
    \caption{Соприкосновение стрелы со стеной}\label{fig:Const-wall}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_pluerarrow.png}
    \caption{Соприкосновение стрелы с игроком}\label{fig:Const-pluerarrow}
\end{figure}

Последней опасностью для игрока является передвигающийся противник. Он представляет собой объект типа sprite с поведением platform и переменными направления и включенности. Перемещение реализовано с помощью события, которое производит перемещение влево или вправо в зависимости от значения переменной направления, потом происходит проверка на то, что противник не будет идти в стену или упадёт с платформы, если проверка неудачная то противник будет развёрнут в обратную сторону. Противник будет включён при первом попадании на экран, и при столкновении с игроком, игрок будет уничтожен. Все события приведены на изображении ~\ref{fig:Const-enemy}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_enemy.png}
    \caption{События противника}\label{fig:Const-enemy}
\end{figure}

Концом уровня считается момент когда игрок достигает выхода. При соприкосновении игрока с выходом вызывается событие меняющее текущий макет и лист событий. При переключении устанавливается значение, равное количеству собранных монет, в текстовый объект. События выполняющие эти действия представлены на рисунках ~\ref{fig:Const-exit} и ~\ref{fig:Const-coincount}. Вид финального экрана представлен на рисунке ~\ref{fig:Const-fin}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_exit.png}
    \caption{Выход с уровня}\label{fig:Const-exit}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_coincount.png}
    \caption{Установка количества собранных монет}\label{fig:Const-coincount}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{Construct_fin.png}
    \caption{Финальный экран}\label{fig:Const-fin}
\end{figure}


\subsection{Реализация на Unity}
При первом запуске открывается стартовый экран идентичный по виду реализованному на Construct. Стартовый экран изображён на на рисунке ~\ref{fig:Const-starting}. Для его изображения используется объект, который находится на объекте со свойством grid, со свойствами tilemap и tilemap renderer для отображения фона стартового экрана, и объект, который находиться на объекте с компонентами canvas, canvas scaler и graphic raycaster, с компонентами canvas renderer и text для отображения текста с управлением. Для того чтобы убрать стартовый экран используется скрипт находящийся в объекте Pluer. В скрипте находиться переменные являющиеся объектами отвечающими за стартовый экран и переменная означающая начальный ли экран сейчас. При выполнении скрипта во время нажатия любой кнопки объекты отвечающие за стартовый экран становятся неактивными, тем самым исчезая с поля зрения игрока, и переменная начального экрана изменяет значение на противоположное. Часть этого скрипта выглядит следующий образом:

\begin{Verbatim}[fontsize=\small, numbers=left]
 public class NewBehaviourScript : MonoBehaviour
 {
     ...
     private bool started = true;
     ...
     // Start is called before the first frame update
     void Start()
     {
         ...
     }
 
     // Update is called once per frame
     void Update()
     {
         ...
         if (started)
                 {
                     if (Input.anyKeyDown)
                     {
                         started = false;
                         uistart.SetActive(false);
                         startScreen.SetActive(false);
                     }
                 }
         ...
     }
 }
\end{Verbatim}

Игрок управляет объектом Pluer со свойствами Box Collider 2D и Circle Collider 2D для определения границ взаимодействия объекта, Rigidbody 2D для определения физических свойств объекта, Sprite Renderer и Animator для отображения объекта в виде статичного и динамичного изображения, последним свойством является скрипт отвечающий за управление пользователем персонажа. 

Основной частью скрипта является перемещение персонажа при нажатии клавиши. Для этого в скрипте объявлены переменные JumpForce,
\newline  MovementSmoothing, runSpeed являющиеся настраемыми напрямую из движка и отвечающие за силу прыжка, сглаживание передвижения и скорость бега. Переменные FloorCheckRadius, FloorCheck, OnFloor, jump, diRight, velocity, horMove, dead отвечающие за радиус проверки стоит ли персонаж, точка относительно которой проходит проверка, стоит ли персонаж на земле, в воздухе ли он, направление по горизонтали, ускорение, скорость перемещения по горизонтали, жив ли персонаж. Эти переменные изменяются программно и не могут быть изменены вне редактора кода. Функция Start определяет компонент RigidBody2D принадлежащий игроку, потом если персонаж жив в функции Update происходит проверка на нажатие клавиш, в функции FixedUpdate происходит реакция на нажатие клавиш вызывая функции floorCheck, отвечающую за проверку на земле ли игрок, Flip, переворачивает систему координат игрока по горизонтали, и Move, отвечающую за изменение текущей скорости игрока. Код отвечающий за перемещение персонажа представлен ниже:

\begin{Verbatim}[fontsize=\small, numbers=left]
 public class NewBehaviourScript : MonoBehaviour
 {
     [SerializeField] private float JumpForce = 400f;
     [Range(0, 0.3f)] [SerializeField] private float MovementSmoothing = 0.05f;
     [SerializeField] private LayerMask Ground;
     [SerializeField] private Transform FloorCheck;
     [SerializeField] private float runSpeed = 40f;
     private bool dead = false;
     const float FloorCheckRadius = 0.2f;
     private bool OnFloor;
     private bool jump = false;
     private bool doubleJump = true;
     private Rigidbody2D myRigidbody2D;
     private bool diRight = true;
     private Vector3 velocity = Vector3.zero;
     private float horMove = 0f;
     ...
     // Start is called before the first frame update
     void Start()
     {
         myRigidbody2D = GetComponent<Rigidbody2D>();
         ...
     }
 
     // Update is called once per frame
     void Update()
     {
         ...
         if (!dead)
                     {
                         horMove = Input.GetAxis("Horizontal") * runSpeed;
                         if (Input.GetButtonDown("Jump"))
                         {
                             ...
                             jump = true;
                         }
                         if (Input.GetButtonDown("Cancel"))
                         {
                             Application.Quit();
                         }
                     }
     }
     private void FixedUpdate()
     {
         if (!dead)
         {
             floorCheck();
             Move(horMove * Time.fixedDeltaTime, jump);
             jump = false;
             floorCheck();
             ...
         } 
     }
     
     private void floorCheck()
     {
         bool onfloor = OnFloor;
         OnFloor = false;
     
         Collider2D[] colliders = Physics2D.OverlapCircleAll(FloorCheck.position, 
             FloorCheckRadius, Ground);
         for (int i = 0; i < colliders.Length; i++)
             {
             if (colliders[i].gameObject != gameObject)
             {
                 OnFloor = true;
                 doubleJump = true;
             }
         }
     }
     private void Move(float move, bool jump)
     {
         Vector3 targetVelocity = new Vector2(move * 10f, myRigidbody2D.velocity.y);
         myRigidbody2D.velocity = Vector3.SmoothDamp(myRigidbody2D.velocity, 
         targetVelocity, ref velocity, MovementSmoothing);
     
         if (move > 0 && !diRight)
         {
             Flip();
         }
         else if (move < 0 && diRight)
         {
             Flip();
         }
         if ((OnFloor && jump) || (doubleJump && curState == State.jump && jump) 
             || (doubleJump && curState == State.fall && jump))
         {
             if (!OnFloor)
             {
                 doubleJump = false;
             }
             OnFloor = false;
             if (myRigidbody2D.velocity.y < 0.1f) myRigidbody2D.velocity = 
             		 new Vector2(myRigidbody2D.velocity.x, 0);
             myRigidbody2D.velocity = new Vector2(myRigidbody2D.velocity.x
                , JumpForce);
             jump = false;
         }
     }
 }
 
 \end{Verbatim}

Для определения какой вид анимации должен быть проигран в данный момент определяется с помощью энумератора State, который включает в себя все возможные состояния, переменной curState, указывающей на текущее состояние, и компонента Animator, который позволяет изменять порядок анимации. Функция Start определяет компонент Animator, принадлежащий игроку, функция Update изменяет положение на прыжок при нажатии клавиши отвечающей за прыжок, функция FixedUpdate вызывает функцию StateChanger, которая отвечает за изменение переменной curState, и изменяет значение состояния внутри компонента Animator. Код отвечающий за изменение анимации представлен ниже:

\begin{Verbatim}[fontsize=\small, numbers=left]
public class PluerMovement : MonoBehaviour
{
    ...
    private Animator anime;    
    private enum State { idle, run, jump, fall, deth, spawn, end }
    private State curState = State.idle;
    ...
    void Start()
    {
        ...
        anime = GetComponent<Animator>();
        ...
    }
    
    void Update()
    {
         ...
             if (!dead)
             {
                 ...
                 if (Input.GetButtonDown("Jump"))
                 {
                      curState = State.jump;
                      ...
                 }
             ...
             }
    }
    
    private void FixedUpdate()
    {
        if (!dead)
        {
            ...
            StateChanger();
            anime.SetInteger("AnimeState", (int)curState);
        } 
    }
    private void StateChanger()
    {
        switch (curState)
        {
             case State.jump:
             {
                  if (myRigidbody2D.velocity.y < -0.001f) curState = State.fall;
             }
             break;
             case State.fall:
             {
                  if (OnFloor) curState = State.idle;
             }
             break;
             default:
             {
                  if (Mathf.Abs(myRigidbody2D.velocity.x) > 1f)
                  {
                       curState = State.run;
                  }
                  else
                  {
                       curState = State.idle;
                  }
                  if (myRigidbody2D.velocity.y < -0.001f && !OnFloor) 
                       curState = State.fall;
             }
             break;
        }
    }
}
\end{Verbatim}
 
Шипы, огонь, стрелы и противник являются сущностями с тэгом DETH. С этим тэгом персонаж может понять с как взаимодействовать при соприкосновении или прохождении сквозь объект с тэгом. При тэге DETH игрок будет считаться погибшим, для этого используются переменные dead и curState, для определения смерти и возрождения персонажа. Функция Start определяет компонент Animator, принадлежащий игроку, функция OnCollisionEnter2D происходит при соприкосновении, OnTriggerEnter2D происходит при прохождении, обе функции изменяют состояние и анимацию.

\begin{Verbatim}[fontsize=\small, numbers=left]
public class PluerMovement : MonoBehaviour
{
    ...
    private bool dead = false;
    private State curState = State.idle;
    ...
    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (!dead)
            switch (collision.gameObject.tag)
            {
                case "DETH":
                {
                    dead = true;
                    curState = State.deth;
                    myRigidbody2D.velocity = new Vector3(0, 0, 0);
                    anime.SetInteger("AnimeState", (int)curState);
                }break;
                default:
                {
                }break;
            }
    }
    
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (!dead)
            switch (collision.gameObject.tag)
             {
                case "DETH":
                {
                    dead = true;
                    curState = State.deth;
                    myRigidbody2D.velocity = new Vector3(0, 0, 0);
                    anime.SetInteger("AnimeState", (int)curState);
                }break;
                ...
                default:
                {
                }break;
             }
    }
    ...
}
\end{Verbatim}

За воскрешение игрока отвечают функции SpawnStart и SpawnEnd. В этих функциях используются компонент Animator для изменения анимации, disabler для выключения ловушек, transform для изменении позиции игрока, Camera для изменения камеры. SpawnStart вызывается при конце анимации смерти игрока и изменяет положение игрока в стартовую точку с нулевой скоростью, в эту же точку перемещается камера, и изменяется анимация на воскрешение. SpawnEnd вызывается после анимации воскрешения и снова включает управление игроку.

\begin{Verbatim}[fontsize=\small, numbers=left]
public class PluerMovement : MonoBehaviour
{
		...
    private void SpawnStart()
    {
        curState = State.spawn;
        Camera.position = new Vector3(13.63f, -0.4199999f, -10f);
        transform.position = SpawnPoint.position;
        myRigidbody2D.velocity = Vector3.zero;
        Animator disabler = LeftShooter.GetComponent<Animator>();
        disabler.SetBool("Enabled", false);
        disabler = RightShooter.GetComponent<Animator>();
        disabler.SetBool("Enabled", false);
        anime.SetInteger("AnimeState", (int)curState);
    }
    
    private void SpawnEnd()
    {
        dead = false;
        Camera.position = new Vector3(13.63f, -0.4199999f, -10f);
        curState = State.idle;
        anime.SetInteger("AnimeState", (int)curState);
    }
}
\end{Verbatim}

Стрельба происходит в сущности Shooter, включающей в себе скрипт с функцией включения и выстрела. Функция включения активируется при прохождении игроком положения триггера, функция стрельбы же активируется с помощью события вызываемого в конце включенной анимации и создающих стрелы в точках создания. Код этих функций представлен ниже:
\begin{Verbatim}[fontsize=\small, numbers=left]
    private void Shoot()
    {
        Instantiate(Arrow, SpawnPoint.position, SpawnPoint.rotation);
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.gameObject.tag == "Player")
        {
            Enabled = true;
            Anime.SetBool("Enabled", Enabled);
        }
    }
\end{Verbatim}

При создании стрел в зависимости от переменной isRight устанавливается скорость и направление в которой летит стрела. Стрелы используют скрипты для изменения состояния на сломанную, и уничтожения стрелы. При прохождения сквозь стену или игрока функция OnTriggerEnter2D стрела становится сломанной и начинает падать вниз. Функция EndArrow вызывается после прохождения 0.05 секунд после вызова OnTriggerEnter2D. Код этих функций представлен ниже:

\begin{Verbatim}[fontsize=\small, numbers=left]

    void Start()
    {
        anime = GetComponent<Animator>();
        myrb = GetComponent<Rigidbody2D>();
        if (isRight) myrb.velocity = new Vector2(speed, 0);
        else myrb.velocity = new Vector2(-speed, 0);
    }
    
    private void OnTriggerEnter2D(Collider2D collision)
    {
        switch (collision.gameObject.tag)
        {
            case "Ground":
                {
                    myrb.velocity = new Vector2(0, -0.5f);
                    myrb.gravityScale = 1;
                    anime.SetBool("Broken", true);
                }
                break;
            case "Player":
                {
                    myrb.velocity = new Vector2(0, -0.5f);
                    myrb.gravityScale = 1;
                    anime.SetBool("Broken", true);
                }
                break;
        }
    }

    private void EndArrow()
    {
        Destroy(gameObject);
    }
\end{Verbatim}

Подбор монет осуществляется с помощью скрипта в сущности Pluer и скрипта в сущности Coin. Скрипт в Player изменяет количество собранных монет и состояние монеты. Скрипт монет имеет только функцию EndSparkle, которая уничтожает монету при конце анимации сбора. Код функций представлен нижу:
\begin{Verbatim}[fontsize=\small, numbers=left]
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (!dead)
            switch (collision.gameObject.tag)
            {
                ...
                case "Coin":
                {
                    counter.text = coinCount.ToString();
                    Animator animeCoin = 
                        collision.gameObject.GetComponent<Animator>();
                    if(!animeCoin.GetBool("Collected")) coinCount++;
                    animeCoin.SetBool("Collected", true);
                }break;
                ...
            }
		}
				
		void EndSparkle()
    {
        Destroy(gameObject);
    }
\end{Verbatim}

Противник использует собственный скрипт для определения перемещения. Он включает в себя переменные и компоненты FloorPoint, isRight, speed, checkRadius, Ground, myrb отвечающие за тоже что и в Pluer. Start определяет компонент myrb и первоначальное ускорение, Update изменяет ускорение, FixedUpdate определяет направление. Код представлен ниже:
\begin{Verbatim}[fontsize=\small, numbers=left]
public class EnemyMovement : MonoBehaviour
{
    [SerializeField] private Transform FloorPoint;
    [SerializeField] private bool isRight;
    [SerializeField] private float speed;
    [SerializeField] private float checkRadius;
    [SerializeField] private LayerMask Ground;
    private Rigidbody2D myrb;

    // Start is called before the first frame update
    void Start()
    {
        myrb = GetComponent<Rigidbody2D>();
        if (isRight) myrb.velocity = new Vector2(speed, 0);
        else myrb.velocity = new Vector2(-speed, 0);
    }

    // Update is called once per frame
    void Update()
    {
        if (isRight) myrb.velocity = new Vector2(speed, 0);
        else myrb.velocity = new Vector2(-speed, 0);
    }

    private void FixedUpdate()
    {
        if(isRight)
        {
            isRight = false;

            Collider2D[] colliders = Physics2D.OverlapCircleAll(FloorPoint.position,
                 checkRadius, Ground); 
            for (int i = 0; i < colliders.Length; i++)
            {
                if (colliders[i].gameObject != gameObject)
                {
                    isRight = true;
                }
            }
            if (!isRight)
            {
                transform.Rotate(0f, 180f, 0f);
            }
        }
        else
        {
            isRight = true;

            Collider2D[] colliders = Physics2D.OverlapCircleAll(FloorPoint.position,
                 checkRadius, Ground);
            for (int i = 0; i < colliders.Length; i++)
            {
                if (colliders[i].gameObject != gameObject)
                {
                    isRight = false;
                }
            }
            if(isRight)
            {
                transform.Rotate(0f, 180f, 0f);
            }
        }

    }
}
\end{Verbatim}

При прохождении игроком выхода функция OnTriggerEnter2D показывает финальный экран идентичный реализованному в Construct. Код представлен ниже:
\begin{Verbatim}[fontsize=\small, numbers=left]
private void OnTriggerEnter2D(Collider2D collision)
    {
        if (!dead)
            switch (collision.gameObject.tag)
            {
                ...
                case "Exit":
                {
                    endgame = true;
                    uiend.SetActive(true);
                    endScreen.SetActive(true);
                    curState = State.idle;
                    myRigidbody2D.velocity = Vector3.zero;
                    transform.position = new Vector3(39.02f, 23.25f, 0f);
                    anime.SetInteger("AnimeState", (int)curState);
                    dead = true;
                }break;
                ...
            }
    }
\end{Verbatim}
\conclusion
В заключении можно сказать, что Construct в следсвие своей простоты позволяет создавать несложные игры без усилий, благодаря этому его лучше использовать чтобы попытаться быть игровым разработчиком или научится самым базовым навыкам разработки. Unity благодаря своему маштабу и возможностям, подходит как для маленьких начинающих компаний так и для крупных компаний. 
%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix


\end{document}
